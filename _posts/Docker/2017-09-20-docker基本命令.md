---
layout: life
title: docker基本命令
category: Docker
duoshuo: true
date: 2017-09-20
---

******

	作者: minus
	版本: V 0.0.1
	日期: 2017年09月20日

<!-- more -->

*******


### Docker-Hub
* 账号/密码: swifthealth :  q1w2e3r4

### docker安装 卸载
* https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-from-a-package
* docker命令集合:  https://docs.docker.com/engine/reference/commandline/export/#description 

### docker 免sudo
```
>sudo groupadd docker
>sudo usermod -aG docker $USER
>sudo service docker restart
>newgrp - docker
```

### dockerhub 提交仓库
```apple js
docker login
docker logout
```

### docker 拷贝本地东西进入容器中 [或者容器内文件拷贝到主机]
```apple js
>docker cp xxx container-name:path
>docker cp ikcest:/root/ikcest/ikcest_main.py ./
```

### 命令行进入正在运行中的container
```apple js
> docker exec -it name /bin/bash
```

### 一次性删掉所有container
```
docker stop $(docker ps -a -q)
docker rm $(docker ps -a -q)
```

### docker容器中的 配置时区问题
```apple js

```

### docker迁移目录
```apple js
https://linuxconfig.org/how-to-move-docker-s-default-var-lib-docker-to-another-directory-on-ubuntu-debian-linux
```

### docker仓库
* https://github.com/docker-library

### docker查看版本
* docker --version

### docker 查看更多的细节
* docker info

### docker 命令
* ```docker run -itd -p 127.0.0.1:8899:8888 -v /home/minus/Public/share_volume:/home/minus/share_volume ubuntu16.04:newest /bin/sh```
* ```docker run -itd -p 127.0.0.1:8080:8080 -p 127.0.0.1:30008:30008 -v /home/minus/Public/share_volume:/home/minus/share_volume ubuntu16.04:vte /bin/sh```

#### 查看容器ip信息命令
* ```docker inspect 571532934bbb | grep IPAddress```

#### 查看容器名称
* ```docker inspect -f "{{ .Name }}" aed84ee21bde```

#### 退出容器而不退出容器do（通过attach进入容器方式）
* ```Ctrl + p + q```
  
#### Dockerfile 配置
    * http://www.alauda.cn/2015/07/17/dockerfileinstructions/

### 容器网络
1. ```docker network connect mynet wy-ubuntu-3```  - 将容器加入一个网络
2. ```docker network rm```  -  删除自定义网络
3. 不推荐使用默认的　bridge 网卡，　--link　通信方式也已经被标记为过去式

### 容器-> 镜像 ->　本地文件
1. 容器保存为镜像
    * ``` docker commit b59 minus/wy-ubuntu:v1```
    
2. 镜像导出
    * ```docker save -o wy-ubuntu.tar minus/wy-ubuntu:v1```
    
3. 镜像导入
    * ```docker load --input xxxx.tar  | docker load < xxxx.tar```
    
### 镜像上传
1. 打标签（user为注册账号名）
    ```docker tag test:latest user/test:latest```
2. push
    ```docker push user/test:latest```
    
###　删除所有docker hi已停止的容器
1. ```docker rm `docker ps -a |awk '{print $1}' | grep [0-9a-z]```

#### docker 测试命令
* remote - mongo : mongo5:30003
* remote - elasticsearch: mongo5:30004/30006
* local - vte_api port : 8080
* local - vte port : 30008

* ```curl -v 'http://127.0.0.1:8080/vte/v1/systemsetting/user/login?username=1000215&password=111111\'```

#### docker - percona
* https://www.percona.com/blog/2014/05/26/installing-three-node-percona-xtradb-cluster-5-6-docker/

#### docker更新　最新版本的二进制
* https://docs.docker.com/engine/installation/binaries/


### docker 基本命令
```apple js
1. docker container ls
2. docker container stop xxx
3. docker image ls
4. docker image rm [-f] xxx
```

### docker run 参数
```apple js
 --rm : 在Docker容器退出时，默认容器内部的文件系统仍然被保留，以方便调试并保留用户数据;设置--rm选项,在容器退出时就能够自动清理容器内部的文件系统;
 -d : 后台运行容器
 -i : 以交互模式运行容器,通常与-t同时使用
 -t : 为容器重新分配一个伪输入终端,通常与-i同时使用
 --name: 为容器指定一个名称
 -e username="minus": 设置环境变量
 --env-file=[]: 从指定文件读入环境变量;
 --expose=[]: 开放一个端口或一组端口
 -m : 设置容器使用内容最大值  
 --cpuset="0-2" or --cpuset="0,1,2": 绑定容器到指定CPU运行；
```

## Swarm
### Docke-engine - Swarm 内置版本（超级简单好用）
1. (官方教程)[https://docs.docker.com/engine/swarm/swarm-tutorial/inspect-service/]
2. 常用命令
    * docker初始化
        ```docker swarm init --force-new-cluster --advertise-addr=```
    * 节点离开集群(节点端)
        ```docker swarm leave```
    * 节点离开集群(manage端)
        ```docker node rm --force <node_name / id>```
    * swarm 节点更新
        ```docker swarm update```
    * swarm 中部署服务
        ```docker service create --replicas 1 --name helloworld alpine ping docker.com```
    * node运行集群container
        ```docker exec -it helloworld.1.99sac60en06h5yjusq1f7ers4 /bin/sh```
    * 查询swarm中服务信息
        ```docker service inspect --pretty helloworld```
    * 查看节点部署情况
        ```docker service ps <service-name>```
    * swarm 中动态扩展服务
        ```docker service scale helloworld=5```
    * swarm　中删除服务
        ```docker service rm helloworld```
     
select inpatient_no, FEE_CODE from FIN_IPB_FEEINFO where inpatient_no='ZY010000660068';
select RECIPE_NO, inpatient_no, FEE_CODE from FIN_IPB_FEEINFO where rownum<=10000000

### Docker - Swarm [http://blog.scottlowe.org/2015/04/19/running-etcd-backed-docker-swarm-cluster/]
    1. 基本知识
        * swarm mode 提供了６种 discovery机制
            * token (默认)
            * node
            * file
            * consul
            * etcd
            * zookeeper
            
    2. 默认token启动：　搭建docker-swarm　集群（默认方式, 不需要设置 docker daemon　重启，默认启动方式）
       * http://www.jianshu.com/p/0ff3181aa886
       * http://www.jianshu.com/p/df744c4e375e
    
    3. 基于　etcd　的 overlay　网络[http://chunqi.li/2015/11/09/docker-multi-host-networking]
       * overlay 网络　是通过 etcd　来发现网络的如果关闭　etcd　服务，将不能在节点主机找不到　overlay网络
       * etcd 建议采用　upstart　启动方式，自启动，配置方便简单，后续不需要人工太多参与
       
    --- 基于 ectd　启动　swarm --- 
    1. 以监听0.0.0.0:2375　监听方式　来启动　docker daemon
        * 修改 /etc/default/docker 文件按，在文件最后添加上：　" DOCKER_OPTS="-H 0.0.0.0:2375 -H unix:///var/run/docker.sock"  "
        * ```sudo service docker restart```
    
    2. 采用　upstart　启动　ectd　节点（如etcd+overlay网络配置一样）
       
    3. 运行 swarm join (every swarm node)
        ```sudo docker run -d swarm join --addr=172.16.1.65:2375 etcd://172.16.1.65:2379/swarm```
        ```sudo docker run -d swarm join --addr=172.16.1.66:2375 etcd://172.16.1.65:2379/swarm```
        ```sudo docker run -d swarm join --addr=172.16.1.67:2375 etcd://172.16.1.65:2379/swarm```
        
        etcd /swarm　目录可通过　```etcdctl ls /swarm/docker/swarm/nodes``` 命令来查看加入的节点情况
        
    4. 运行 swarm manage (manage node)
        ```sudo docker run -d -p 8333:2375 swarm manage etcd://172.16.1.65:2379/swarm```
   
### etcd + container(**已经过时**):
```
docker run -d -v /usr/share/ca-certificates/:/etc/ssl/certs -p 4001:4001 -p 2380:2380 -p 2379:2379 --name etcd quay.io/coreos/etcd -name etcd0 -advertise-client-urls http://172.16.1.65:2379,http://172.16.1.65:4001 -listen-client-urls http://0.0.0.0:2379,http://0.0.0.0:4001 -initial-advertise-peer-urls http://172.16.1.65:2380 -listen-peer-urls http://0.0.0.0:2380 -initial-cluster-token etcd-cluster-1 -initial-cluster etcd0=http://172.16.1.65:2380,etcd1=http://172.16.1.66:2380,etcd2=http://172.16.1.67:2380 -initial-cluster-state new

docker run -d -v /usr/share/ca-certificates/:/etc/ssl/certs -p 4001:4001 -p 2380:2380 -p 2379:2379 \
 --name etcd quay.io/coreos/etcd \
 -name etcd0 \
 -advertise-client-urls http://172.16.1.65:2379,http://172.16.1.65:4001 \
 -listen-client-urls http://0.0.0.0:2379,http://0.0.0.0:4001 \
 -initial-advertise-peer-urls http://172.16.1.65:2380 \
 -listen-peer-urls http://0.0.0.0:2380 \
 -initial-cluster-token etcd-cluster-1 \
 -initial-cluster etcd0=http://172.16.1.65:2380,etcd1=http://172.16.1.66:2380,etcd2=http://172.16.1.67:2380 \
 -initial-cluster-state new
```

### etcd + overlay网络 docker集群 [http://chunqi.li/2015/11/09/docker-multi-host-networking/ : **这种方式已经过时了**]
    1. etcd启动参数（/etc/init/etcd.override）- 注意　ip 配置方式
        * listen 使用　0.0.0.0
        * advertise　使用　node_ip　＋　127.0.0.1
        ```
        env ETCD_INITIAL_CLUSTER="etcd-01=http://172.16.1.65:2380,etcd-02=http://172.16.1.66:2380,etcd-03=http://172.16.1.67:2380"
        env ETCD_INITIAL_CLUSTER_STATE="new"
        env ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster-01"
        env ETCD_INITIAL_ADVERTISE_PEER_URLS="http://172.16.1.65:2380"
        env ETCD_DATA_DIR="/var/etcd"
        env ETCD_LISTEN_PEER_URLS="http://<0.0.0.0> | <node_ip>:2380"
        env ETCD_LISTEN_CLIENT_URLS="http://<node_ip> | <0.0.0.0>:2379,http://<127.0.0.1>|<0.0.0.0>:4001"
        env ETCD_ADVERTISE_CLIENT_URLS="http://<node_ip> | <0.0.0.0>:2379"
        env ETCD_NAME="etcd-01"
        ```
    2. etcd 启动文件（/etc/init/etcd.conf）
        ```
        description "etcd 2.0 distributed key-value store"
        author "Scott Lowe <scott.lowe@scottlowe.org>"
        
        start on (net-device-up
                  and local-filesystems
                  and runlevel [2345])
        stop on runlevel [016]
        
        respawn
        respawn limit 10 5
        
        script
          if [ -f "/etc/default/etcd" ]; then
            . /etc/default/etcd
          fi
        
        chdir /var/etcd
        exec /usr/local/bin/etcd >>/var/log/etcd.log 2>&1
        end script
        ```
        
    3. 启动　etcd　服务
        ```sudo initctl start etcd```
        
    4. 基于etcd的overlay docker重启方式：采用嫁接　Etcd 的命令启动: docker daemon命令 - 这样就可以通过 etcd　去发现网络了：
        * ```sudo docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --cluster-store=etcd://172.16.1.65<node_ip>:2379 --cluster-advertise=172.16.1.65<node_ip>:2375```
        
    5. 开启 并　查看 overlay　网络
        * ```docker network create -d overylay myapp ```
        * ```docker network list```

3. 学校三台docker服务器
    * docker1: 172.16.1.65 - 71
    * docker2: 172.16.1.66 - 72
    * docker3: 172.16.1.67 - 73

4. Etcd安装(采用 upstart 来启动)
    1. etcd创建集群博客[http://blog.scottlowe.org/2015/04/15/running-etcd-20-cluster/]　
        * 注意　ETCD_ADVERTISE_CLIENT_URLS　和　ETCD_LISTEN_CLIENT_URLS　都设置成　'127.0.0.1'

### docker-engine swarm(own) + etcd + service [http://www.jianshu.com/p/df744c4e375e]
(终极教程)[http://severalnines.com/blog/mysql-docker-introduction-docker-swarm-mode-and-multi-host-networking][http://blog.dataman-inc.com/shurenyun-docker-175/]
         [https://www.percona.com/blog/2016/06/14/scaling-percona-xtradb-cluster-proxysql-docker-swarm/]
(终极搭建etcd服务器：两种方式)[http://blog.csdn.net/u010511236/article/details/52386229]
1. 创建docker swarm 并添加nodes:
    ```docker swarm init --advertise-addr 172.16.1.65```
2. 创建etcd-discovery: [官方发现服务器，不推荐，建议使用自己的etcd集群(http://blog.scottlowe.org/2015/04/15/running-etcd-20-cluster/)]
    ```curl -w "\n" 'https://discovery.etcd.io/new?size=3'```
3. 创建overlay-mynet: 
    ```docker network create --driver overlay mynet```
4. 创建docker service-etcd:
    0. 关于如何创建自己的 etcd　服务器集群，参考[http://blog.scottlowe.org/2015/04/15/running-etcd-20-cluster/]
    1. 关于 etcd　发现服务器　而言，你可以自己搭建一个etcd来找，或者采用官方的etcd发现服务器, 下面是注意事项
        * 自己搭建服务器的方式中注意：```curl -X PUT http://172.16.1.65:2379/v2/keys/discovery/6c107a14875d53d9bf0ef5a6fc0257c81730fb14/_config/size -d value=1```　中 value 值　与你创建的　etcd 服务 replicas个数保持一致，比如　value=1 与 replicas 1
    2. etcd官网提供discovery-url : ```docker service create --name etcd --replicas 1 --network mynet -p 2379:2379 -p 2380:2380 -p 4001:4001 -p 7001:7001 elcolio/etcd:latest -name etcd -discovery=https://discovery.etcd.io/71aeb60c367322d886e6525e01e18171```
    3. 自己etcd集群提供discovery-url: ```docker service create --name etcd --replicas 1 --network mynet -p 2379:2379 -p 2380:2380 -p 4001:4001 -p 7001:7001 elcolio/etcd:latest -name etcd -discovery=http://172.16.1.65:2379/v2/keys/discovery/6c107a14875d53d9bf0ef5a6fc0257c81730fb19```
5. 创建docker percona-service [ percona 需要 etcd　去发现节点]: 
    ```docker service create --name mysql-galera --replicas 3 -p 3307:3306 --network mynet --env MYSQL_ROOT_PASSWORD=minus --env DISCOVERY_SERVICE=10.0.0.2:2379 --env XTRABACKUP_PASSWORD=minus --env CLUSTER_NAME=galera percona/percona-xtradb-cluster:latest```
6. swarm percona cluster 测试：
    * ```while true; do mysql -uroot -pmypassword -h127.0.0.1 -P3306 -NBe 'select @@wsrep_node_address'; sleep 1; done```
7. 创建一个服务器代理 perconalab/proxysql　服务service [参考: https://www.percona.com/blog/2016/06/14/scaling-percona-xtradb-cluster-proxysql-docker-swarm/]
    * 创建一个代理服务(3306指向3308, 6032指向6032)
        * ```docker service create --name mysql-proxy --replicas 1 -p 3308:3306 -p 6032:6032  --network mynet --env MYSQL_ROOT_PASSWORD=minus --env DISCOVERY_SERVICE=10.0.0.2:2379 --env MYSQL_PROXY_USER=proxyuser --env MYSQL_PROXY_PASSWORD=minus --env CLUSTER_NAME=galera perconalab/proxysql:latest```
        * 保证有　MYSQL_ROOT_PASSWORD |　DISCOVERY_SERVICE |　CLUSTER_NAME |　MYSQL_PROXY_USER　|　MYSQL_PROXY_PASSWORD
        * 其中　MYSQL_ROOT_PASSWORD |　DISCOVERY_SERVICE |　CLUSTER_NAME　这三个要保证与　percona 配置的参数是一致的
    * 创建好之后　需要在 proxysql　中注册　Percona XtraDB Cluster
        * ```docker exec -it mysql-proxy.1.zv5azbxxdftra2mfoau4i79zc add_cluster_nodes.sh```
    * 通过 proxysql:3306-3308 访问三台 percona-cluster 的具体数据
        * ```mysql -h127.0.0.1 -P3308 -uproxyuser -pminus```
    * 通过 proxysql:6032-6032 访问 管理端口，可以查看集群机器情况
        * ```mysql -h127.0.0.1 -P6032 -uadmin -padmin``` (账号密码　默认都是 admin)
        * ```select * from stats.stats_mysql_connection_pool;```  -　查看集群机器

=============================================================================
```
概念：
1. The major difference between a container and an image is the top writable layer
2.
```
```
docker命令集合: https://docs.docker.com/engine/reference/commandline/dockerd/
```

### docker进入到容器命令[pg容器为例]
```
docker-machine Git-Repository: https://github.com/docker/machine/releases
安装 docker-machine: https://docs.docker.com/machine/install-machine/
-t : 让docker分配一个伪终端并绑定到容器的标准输入上
-i : 让容器的标准输入保持打开
docker账号: miminus   lianxiang
docker login   : 登陆 Docker public registry,　用于登陆
docker run -idt --name pg9.6 -e POSTGRES_PASSWORD=lianxiang -d pg_9.6
docker exec -it name /bin/bash
docker start container-name  - 启动未启动的docker容器
docker stop container-name   - 关闭正在运行的docker容器
docker tag image-name username/repository:tag  - 给已有的镜像打标签,以备上传


docker push miminus/get-started:web  - 本地docker上传到　DockerHub(先登陆 docker login)

显示所有容器(包括未运行): docker ps -a
只显示在运行中的容器: docker ps
删除未运行容器: docker rm <container_id>
删除镜像: docker rmi repository:tag
```

### 镜像集
1. postgresql [https://github.com/docker-library/postgres/tree/bef8f02d1fe2bb4547280ba609f19abd20230180]
```
/usr/share/postgresql/9.6
/usr/lib/postgresql/9.6/bin
配置文件：/var/lib/postgresql/data

docker run -idt --name pg9.6 -e POSTGRES_PASSWORD=lianxiang -d pg_9.6
docker exec -it container-name /bin/bash
docker start container-name
docker run -d -it --name devtest --mount source=myvol2,target=/app nginx:latest
```

### docker Swarm
```
docker swarm init [--advertise-addr 192.168.1.9] 多个ip情况下　- docker 初始化
docker stack deploy -c docker-compose.yml getstartedlab<new-name>
docker service ls               - get service-id for the one service
docker container ls -q          - list all 5 containers-ids
docker service ps <service>     - 查看状态和它们的IDs
docker stack ps getstartedlab   - 查看各个容器运行状况
docker stack rm getstartedlab   - take down the app but not swarm [one-node swarm is still up and running]
docker node ls                  - 查看节点情况
docker swarm leave --force      - take down the swarm
```

### docker-machine
```
docker-machine create --driver virtualbox myvm1             # 创建一个 virtualbox 的虚拟机
docker-machine ls                                           # 获取 vm 信息及其 ips
docker-machine ssh myvm1                                    # ssh进入到 虚拟机终端
docker-machine ssh myvm1 "docker stack rm getstartedlab"    # 关闭服务器上的服务
docker-machine ssh myvm2 "docker swarm leave"               # run on worker
docker-machine ssh myvm1 "docker swarm leave --force"       # run on manager
docker-machine env 和 docker-machine ssh
docker-machine scp <file> <machine>:~

删除虚拟机docker-machine
1. docker-machine stop myvm1
2. docker-machine rm myvm1

3. docker-machine start myvm1   # 启动关闭的machine
```

### docker-network
```
docker network ls                               # 查看网络
docker network disconnect bridge networktest    # 将一个容器取消绑定一个网络
docker network create -d bridge my_bridge       # 创建一个桥接网络
docker network inspect my_bridge                # 查看一个网络的情况（包括IP子网范围）
docker run -d --net=my_bridge --name db training/postgres   # 将容器启动添加入指定网络
docker inspect --format='{{json.NetworkSettings.Networks}}' db<container-name>      # 查看某个容器的所在网络
docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' web  # 获取某个容器的IP

* 一个容器可以绑定到多个网络中，不同网络中的容器之间不能通信的，
docker network connect my_bridge web            # 将正在运行的容器绑定到新的网络中
```

### docker volume[https://docs.docker.com/engine/admin/volumes/volumes/#start-a-container-with-a-volume]
```
docker volume create my-vol
docker volume ls
docker volume rm my-vol
```




### Dockerfile
```
reference: https://docs.docker.com/engine/reference/builder/#run

.dockerignore 用于排除不用的文件或者文件夹
将应用解耦到多个容器中，有利于水平扩展和容器复用　－　“one process per container”

docker build -t xxx/xxx path

- 命令
```
FROM:               # 第一条指令必须为FROM指令，如果在一个Dockerfile中创建多个镜像时，可以使用多个FROM指令。
FROM xxx/xxx
```
```
MAINTAINER:         # 指定维护者信息。
MAINTAINER name@email.com
```
```
USER                # USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层
- WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份
```
```
ARG XXX=latest      # 定义常量　使用方法 ${XXX}：　构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的
```
```
ENV                 # 指定环境变量
ENV NAME World
```
```
WORKDIR             # 指定工作目录　指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录

```
```
ADD                 # 复制指定的到容器中的。可以为相对路径，URL或者tar文件均可。　- 自动解压缩文件
ADD . /APP          # HOST主机当前目录下文件加入并解压到容器中 /APP的目录下
- 最好的使用是用来拷贝一个压缩文件进去并进行解压
```
```
COPY                # 复制本地主机的到容器中的。 源文件的元数据会保留，如读／写／权限／时间等
```
```
VOLUME              # 创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。
VOLUME ["/data", "", ...]
VOLUME <path>
```
```
RUN                 # 每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更
RUN apt-get update && apt-get install -y \
  bzr \
  cvs \
  git \
  mercurial \
  subversion
RUN ['executable', 'param1', 'param2']
```
```
ENTRYPOINT          # 当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令
ENTRYPOINT [ "curl", "-s", "http://ip.cn" ]
ENTRYPOINT ["docker-entrypoint.sh"]
```
```
EXPOSE              # 指定Docker容器开放的端口号
EXPOSE 80
```
```
